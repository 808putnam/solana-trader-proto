syntax = "proto3";
package ffi;
option go_package = "github.com/bloXroute-Labs/solana-trader-api/proto/ffi";

import "api.proto";

/*
FFI service definition for binding to external Typescript implementations.

The FFI service should avoid network calls, since it makes calls to the regular Solana RPC endpoint. Instead, accounts
should be provided over this interface from for e.g. Geyser stream.

The initialization of this service is a bit complex, since API and FFI service have dependencies both ways. The flow
should be as follows:

1. FFI server starts its GRPC component and binds to an interface. At this point, it does not yet do anything.
2. API starts and connects to FFI server. API opens a connection for FFI to query accounts.
3. API starts querying if FFI server is ready.
4. FFI server requests and loads accounts, then initializes Jupiter classes. Once ready, flips the boolean and
   indicates all accounts API should track (so it doesn't try to store literally every account from Geyser)
5. API continues normal startup.

More visual representation:

  1.0 FFI (starts)

  2.0 FFI <- SolanaAccountsStream() <- API (starts and opens stream)

  3.0 FFI <- JupiterIsReadyRequest() <- API (repeatedly on interval)
  3.1 FFI -> JupiterIsReadyResponse(false, []) -> API (not ready)

  4.0 FFI -> SolanaAccountsRequest() -> API (initializing)
  4.1 FFI <- SolanaAccountsResponse() <- API (initializing)
  4.2 FFI -> JupiterIsReadyResponse(true, [accountIDs]) -> API

  5.0 FFI <-> SolanaAccountsRequest() (etc.) -> API (normal operation)
  5.1 FFI <-> JupiterComputeRoutes() (etc.) <-> API (normal operation)
 */

service FFI {
  // reversed streaming: API provides accounts
  rpc SolanaAccountsStream(stream SolanaAccountsResponse) returns (stream SolanaAccountsRequest) {}

  rpc JupiterIsReady(JupiterIsReadyRequest) returns (JupiterIsReadyResponse) {}
  rpc JupiterPairToAccounts(JupiterPairToAccountsRequest) returns (JupiterPairToAccountsResponse) {}
  rpc JupiterComputeRoutes(JupiterComputeRoutesRequest) returns (JupiterComputeRoutesResponse) {}
  rpc JupiterSwapTx(JupiterSwapTxRequest) returns (JupiterSwapTxResponse) {}

}
message SolanaAccountsRequest {
  repeated string accountIDs = 1;
}

message SolanaAccountsResponse {
  // accounts can be null if not found: in that case, check to see if owner field is set
  repeated SolanaAccount accounts = 1;

  // empty if in response to a request, filled if unsolicited push
  repeated string accountIDs = 2;

  // signal for errors processing response
  string error = 3;
}

message SolanaAccount {
  uint64 lamports = 1;
  bytes owner = 2;
  string data = 3;
  bool executable = 4;
  uint64 rentEpoch = 5;
}

message JupiterPairToAccountsRequest {
  string inputMint = 1;
  string outputMint = 2;
}

message JupiterPairToAccountsResponse {
  repeated string accountIDs = 2;
}

message JupiterIsReadyRequest {}

message JupiterIsReadyResponse {
  bool ready = 1;
  repeated string accountIDs = 2;
}

message JupiterComputeRoutesRequest {
  string inputMint = 1;
  string outputMint = 2;
  uint64 amount = 3; // https://github.com/protocolbuffers/protobuf/issues/3666#issuecomment-330794708 maybe a problem?
  double slippage = 4;
}

message JupiterComputeRoutesResponse {
  repeated JupiterRouteInfo routeInfos = 1;
}

message JupiterSwapTxRequest {
  repeated JupiterMarketInfo steps = 1;
  float inAmount = 2;
  float outAmount = 3;
  float amount = 4;
  float otherAmountThreshold = 5;
  JupiterSwapMode swapMode = 6;
  api.PriceImpactPercent priceImpactPercent = 7;
  string userPublicKey = 8;
}

message JupiterSwapTxResponse {
  repeated TransactionMessage transactions = 1;
}

// FFI version of a TransactionMessage so that the transaction in bytes does not prematurely become an api.TransactionMessage (string)
// before it has to turn into an amm.TransactionMessage (bytes)
message TransactionMessage {
  bytes content = 1;
  bool isCleanup = 2;
}

message JupiterRouteInfo {
  repeated JupiterMarketInfo marketInfos = 1;
  float inAmount = 2;
  float outAmount = 3;
  float amount = 4;
  float otherAmountThreshold = 5;
  JupiterSwapMode swapMode = 6;
  api.PriceImpactPercent priceImpactPercent = 7;
}

message JupiterMarketInfo {
  JupiterAmm amm = 1;
  string inputMint = 2;
  string outputMint = 3;
  float inAmount = 4;
  float outAmount = 5;
  api.PriceImpactPercent priceImpactPercent = 6;
  api.Fee liquidityPoolFee = 7;
  api.Fee platformFee = 8;
  bool notEnoughLiquidity = 9;
}

message JupiterAmm {
  string label = 1;
  string id = 2;
}

enum JupiterSwapMode {
  JSM_EXACT_IN = 0;
  JSM_EXACT_OUT = 1;
}
