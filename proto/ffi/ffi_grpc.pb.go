// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package ffi

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// FFIClient is the client API for FFI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FFIClient interface {
	// reversed streaming: API provides accounts
	SolanaAccountsStream(ctx context.Context, opts ...grpc.CallOption) (FFI_SolanaAccountsStreamClient, error)
	JupiterIsReady(ctx context.Context, in *JupiterIsReadyRequest, opts ...grpc.CallOption) (*JupiterIsReadyResponse, error)
	JupiterPairToAccounts(ctx context.Context, in *JupiterPairToAccountsRequest, opts ...grpc.CallOption) (*JupiterPairToAccountsResponse, error)
	JupiterComputeRoutes(ctx context.Context, in *JupiterComputeRoutesRequest, opts ...grpc.CallOption) (*JupiterComputeRoutesResponse, error)
	JupiterSwapTx(ctx context.Context, in *JupiterSwapTxRequest, opts ...grpc.CallOption) (*JupiterSwapTxResponse, error)
}

type fFIClient struct {
	cc grpc.ClientConnInterface
}

func NewFFIClient(cc grpc.ClientConnInterface) FFIClient {
	return &fFIClient{cc}
}

func (c *fFIClient) SolanaAccountsStream(ctx context.Context, opts ...grpc.CallOption) (FFI_SolanaAccountsStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &FFI_ServiceDesc.Streams[0], "/ffi.FFI/SolanaAccountsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &fFISolanaAccountsStreamClient{stream}
	return x, nil
}

type FFI_SolanaAccountsStreamClient interface {
	Send(*SolanaAccountsResponse) error
	Recv() (*SolanaAccountsRequest, error)
	grpc.ClientStream
}

type fFISolanaAccountsStreamClient struct {
	grpc.ClientStream
}

func (x *fFISolanaAccountsStreamClient) Send(m *SolanaAccountsResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fFISolanaAccountsStreamClient) Recv() (*SolanaAccountsRequest, error) {
	m := new(SolanaAccountsRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fFIClient) JupiterIsReady(ctx context.Context, in *JupiterIsReadyRequest, opts ...grpc.CallOption) (*JupiterIsReadyResponse, error) {
	out := new(JupiterIsReadyResponse)
	err := c.cc.Invoke(ctx, "/ffi.FFI/JupiterIsReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFIClient) JupiterPairToAccounts(ctx context.Context, in *JupiterPairToAccountsRequest, opts ...grpc.CallOption) (*JupiterPairToAccountsResponse, error) {
	out := new(JupiterPairToAccountsResponse)
	err := c.cc.Invoke(ctx, "/ffi.FFI/JupiterPairToAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFIClient) JupiterComputeRoutes(ctx context.Context, in *JupiterComputeRoutesRequest, opts ...grpc.CallOption) (*JupiterComputeRoutesResponse, error) {
	out := new(JupiterComputeRoutesResponse)
	err := c.cc.Invoke(ctx, "/ffi.FFI/JupiterComputeRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFIClient) JupiterSwapTx(ctx context.Context, in *JupiterSwapTxRequest, opts ...grpc.CallOption) (*JupiterSwapTxResponse, error) {
	out := new(JupiterSwapTxResponse)
	err := c.cc.Invoke(ctx, "/ffi.FFI/JupiterSwapTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FFIServer is the server API for FFI service.
// All implementations must embed UnimplementedFFIServer
// for forward compatibility
type FFIServer interface {
	// reversed streaming: API provides accounts
	SolanaAccountsStream(FFI_SolanaAccountsStreamServer) error
	JupiterIsReady(context.Context, *JupiterIsReadyRequest) (*JupiterIsReadyResponse, error)
	JupiterPairToAccounts(context.Context, *JupiterPairToAccountsRequest) (*JupiterPairToAccountsResponse, error)
	JupiterComputeRoutes(context.Context, *JupiterComputeRoutesRequest) (*JupiterComputeRoutesResponse, error)
	JupiterSwapTx(context.Context, *JupiterSwapTxRequest) (*JupiterSwapTxResponse, error)
	mustEmbedUnimplementedFFIServer()
}

// UnimplementedFFIServer must be embedded to have forward compatible implementations.
type UnimplementedFFIServer struct {
}

func (UnimplementedFFIServer) SolanaAccountsStream(FFI_SolanaAccountsStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SolanaAccountsStream not implemented")
}
func (UnimplementedFFIServer) JupiterIsReady(context.Context, *JupiterIsReadyRequest) (*JupiterIsReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JupiterIsReady not implemented")
}
func (UnimplementedFFIServer) JupiterPairToAccounts(context.Context, *JupiterPairToAccountsRequest) (*JupiterPairToAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JupiterPairToAccounts not implemented")
}
func (UnimplementedFFIServer) JupiterComputeRoutes(context.Context, *JupiterComputeRoutesRequest) (*JupiterComputeRoutesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JupiterComputeRoutes not implemented")
}
func (UnimplementedFFIServer) JupiterSwapTx(context.Context, *JupiterSwapTxRequest) (*JupiterSwapTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JupiterSwapTx not implemented")
}
func (UnimplementedFFIServer) mustEmbedUnimplementedFFIServer() {}

// UnsafeFFIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FFIServer will
// result in compilation errors.
type UnsafeFFIServer interface {
	mustEmbedUnimplementedFFIServer()
}

func RegisterFFIServer(s grpc.ServiceRegistrar, srv FFIServer) {
	s.RegisterService(&FFI_ServiceDesc, srv)
}

func _FFI_SolanaAccountsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FFIServer).SolanaAccountsStream(&fFISolanaAccountsStreamServer{stream})
}

type FFI_SolanaAccountsStreamServer interface {
	Send(*SolanaAccountsRequest) error
	Recv() (*SolanaAccountsResponse, error)
	grpc.ServerStream
}

type fFISolanaAccountsStreamServer struct {
	grpc.ServerStream
}

func (x *fFISolanaAccountsStreamServer) Send(m *SolanaAccountsRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fFISolanaAccountsStreamServer) Recv() (*SolanaAccountsResponse, error) {
	m := new(SolanaAccountsResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FFI_JupiterIsReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JupiterIsReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFIServer).JupiterIsReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffi.FFI/JupiterIsReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFIServer).JupiterIsReady(ctx, req.(*JupiterIsReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFI_JupiterPairToAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JupiterPairToAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFIServer).JupiterPairToAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffi.FFI/JupiterPairToAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFIServer).JupiterPairToAccounts(ctx, req.(*JupiterPairToAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFI_JupiterComputeRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JupiterComputeRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFIServer).JupiterComputeRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffi.FFI/JupiterComputeRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFIServer).JupiterComputeRoutes(ctx, req.(*JupiterComputeRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFI_JupiterSwapTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JupiterSwapTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFIServer).JupiterSwapTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffi.FFI/JupiterSwapTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFIServer).JupiterSwapTx(ctx, req.(*JupiterSwapTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FFI_ServiceDesc is the grpc.ServiceDesc for FFI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FFI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ffi.FFI",
	HandlerType: (*FFIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JupiterIsReady",
			Handler:    _FFI_JupiterIsReady_Handler,
		},
		{
			MethodName: "JupiterPairToAccounts",
			Handler:    _FFI_JupiterPairToAccounts_Handler,
		},
		{
			MethodName: "JupiterComputeRoutes",
			Handler:    _FFI_JupiterComputeRoutes_Handler,
		},
		{
			MethodName: "JupiterSwapTx",
			Handler:    _FFI_JupiterSwapTx_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SolanaAccountsStream",
			Handler:       _FFI_SolanaAccountsStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "ffi.proto",
}
